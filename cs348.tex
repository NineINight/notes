\documentclass[]{article}
\usepackage{etex}
\usepackage[margin = 1.5in]{geometry}
\setlength{\parindent}{0in}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{color}
\usepackage{mathtools}
\usepackage{pgfplots}
\usepackage{float}
\usepackage[T1]{fontenc}
\usepackage{ae,aecompl}
\usepackage[pdftex,
  pdfauthor={Michael Noukhovitch},
  pdftitle={CS 348: Intro to Database Management},
  pdfsubject={Lecture notes from CS 348 at the University of Waterloo},
  pdfproducer={LaTeX},
  pdfcreator={pdflatex}]{hyperref}

\usepackage{cleveref}
\usepackage{enumitem}
\usepackage{multicol}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4
}

\theoremstyle{definition}
\newtheorem*{defn}{Definition}
\newtheorem{ex}{Example}[section]
\newtheorem*{theorem}{Theorem}

\setlength{\marginparwidth}{1.5in}

\DeclarePairedDelimiter{\set}{\lbrace}{\rbrace}

\definecolor{darkish-blue}{RGB}{25,103,185}

\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=darkish-blue,
    filecolor=darkish-blue,
    linkcolor=darkish-blue,
    urlcolor=darkish-blue
}
\newcommand{\lecture}[1]{\marginpar{{\footnotesize $\leftarrow$ \underline{#1}}}}

\makeatletter
\def\blfootnote{\gdef\@thefnmark{}\@footnotetext}
\makeatother

\begin{document}
	\let\ref\Cref

	\title{\bf{CS 348: Intro to Database Management}}
	\date{Winter 2015, University of Waterloo \\ \center Notes written from Grant Weddel's lectures.}
	\author{Michael Noukhovitch}

	\maketitle
	\newpage
	\tableofcontents
	\newpage

	\section{Introduction}
		\subsection{DBMS}
			\subsubsection{Definitions}
				\textbf{Database}: a large and persistent collection of data \\
				\textbf{DBMS}: a program that manages details for storage and access to a db \\
				\textbf{Schema}: a description of the data interface to the database \\
				to abstract common functions and create a uniform interface we need:
				\begin{itemize}
					\item \textbf{data model}: all data stored uniformally
					\item \textbf{access control}: authorization to modify/view
					\item \textbf{concurrency control}: multiple applications can access at same time 
					\item \textbf{database recovery}: nothing is lost 
					\item \textbf{database maintenance}
				\end{itemize}
			\subsubsection{Three-Level Schema}
				\textbf{external schema}: what the app and user see \\
				\textbf{conceptual schema}: description of the logical structure of the data \\
				\textbf{physical schema}: description of physical aspects (storage
	algorithms \ldots{}) \\
	
				DBMS allows the data to be stored via the physical schema, reasoned via the conceptual schema, and accessed via the external schema.
	
			\subsubsection{Interfacing}
				Interfacing to DBMS, we can interact with it through: \\
				\textbf{Data Definition Language}: specifies schemas 
				\begin{itemize}
					\item may be different for each schema 
					\item the \textbf{data dictionary} (or \textbf{catalog}) stores the information
				\end{itemize}				

				\textbf{Data Manipulation Language}: specifies queries and updates \emph{(e.g SQL)}
				\begin{itemize}
					\item navigational (procedural)
					\item non-navigational (declarative)
				\end{itemize}								
				\subsubsection{DBAs}
				Database administrators are responsible for:
				\begin{itemize}
					\item managing conceptual schema
					\item assisting with app view integration
					\item monitoring and tuning DBMS performance
					\item defining internal schema
					\item loading and reformating DB
					\item security and reliability
				\end{itemize}
		\subsection{Big Ideas}
			There are three big ideas which have influenced the creation and development of databases
			\subsubsection{Quantification}
				Database queries can be described by relational algebra as quantifiers	
				
			\subsubsection{Data Independence}
				\textbf{Data Independence}: allow each schema to be independant of the others
				\begin{itemize}
					\item \textbf{physical independance}: application immune to changes
	in storage structure
					\item \textbf{logical independence}: application immune to changes in data organization
				\end{itemize}
			\subsubsection{Transaction}
				\textbf{Transaction}: an application-specified atomic and durable unit of work \\
				\textbf{ACID}: transaction properties ensured by the DBMS
				\begin{itemize}
					\item \textbf{atomic}: a transaction cannot be split up 
					\item \textbf{consistency}: each transaction preserves consistency 
					\item \textbf{isolated}: concurrent transaction don't interfere with each other 
					\item \textbf{durable}: once completed, changes are permanent
				\end{itemize}

				
	\section{Relational Model}
		\subsection{Definitions}
			\textbf{Relational model}: all information is organized in (flat) relations
			\begin{itemize}
				\item powerful and declarative query language
				\item semantic integrity constraints (using first order logic)
				\item data independence
			\end{itemize}	
		\subsection{Properties}
			\begin{itemize}
				\item based on finite set theory
					\begin{itemize}
						\item attribute ordering \textit{not strictly necessary}
						\item tuples identified by attribute values
						\item instance has set semantics \textit{no ordering, no duplicates}
					\end{itemize}
				\item all attribute values are atomic 
				\item \textbf{degree}: number of attributes in schema
				\item \textbf{cardinality}: number of tuples in instance
			\end{itemize}			 			
				
			We can algebraically define databases as a finite set of relation schemas
		\subsection{Relations vs SQL Tables}
			SQL has extensions on top of the relational model:
			\begin{enumerate}
				\item semantics of instances:
					\begin{itemize}
						\item relations are \textbf{sets} of tuples
						\item tables are \textbf{multisets} (bags) of tuples 
					\end{itemize}
				\item unknown values: SQL includes \lstinline|Null|
			\end{enumerate}
	\section{Relation Algebra}
		\subsection{Primary Operators}
			\begin{itemize}
				\item \textbf{Relation Name}: $R$
				\item \textbf{Selection}: $\sigma_{condition}(E)$ satisfies some condition
				\item \textbf{Projection}: $\pi_{attributes}(E)$ only includes these attributes
				\item \textbf{Rename}: $\rho(R(\bar{F}),E)$ (where $\bar{F}$ is a list of $oldname \mapsto newname$)
				\item \textbf{Product}: $E_1 \times E_2$
			\end{itemize}	
		\subsection{Joins}
			\begin{itemize}
				\item \textbf{Conditional Join}: $E_1 \Join_{condition} E_2$
				\item \textbf{Natural Join}: $E_1 \Join E_2$ common attributes
			\end{itemize}			
		\subsection{Set Operators}
			Schemas $R$ and $S$ must be \textbf{union compatible}: have same number (and type) of fields
			\begin{itemize}
				\item \textbf{Union}: $R \cup S$
				\item \textbf{Difference}: $R - S$
				\item \textbf{Intersection}: $R \cap S$
				\item \textbf{Division}: $R \mathbin{/} S$ (\textit{opposite of $\times$})
			\end{itemize}															
	\section{SQL}
		\subsection{SQL Standard}
			\begin{description}
				\item[Data Manipulation Language]: query and modify tables
				\item[Data Definition Language]: create tables and enforce access/security
			\end{description}				
			\begin{ex}
				Basic query block
				\begin{lstlisting}[language=SQL]
select attribute-list
from relation-list
[where condition]
				\end{lstlisting}
			\end{ex}			
		\subsection{DML}
			\subsubsection{Null}
				A necessary evil that indicates unknown or missing data
				\begin{itemize}
					\item test using \lstinline|is (not) NULL|
					\item expressions with \lstinline|NULL| e.g. \lstinline|x + NULL = NULL|
					\item \lstinline|where| treats \lstinline|NULL| like \lstinline|False|
				\end{itemize}
			\subsubsection{Subquery}
				\lstinline|where| supports predicates as part of its clause
				\begin{ex} select all employees with the highest salary
					\begin{lstlisting}[language=SQL]
select empno, lastname
from employee
where salary >= all
 	( select salary
	 from employee )				
					\end{lstlisting}
				\end{ex}
			\subsubsection{Ordering}
				No ordering can be assumed unless you use \lstinline|order by|
			\subsubsection{Grouping}
				\lstinline|group by| allows you to aggregate results
				\begin{ex} for each dept, list number of employees and combined salary
				\begin{lstlisting}[language=SQL]
select deptno, deptname, sum(salary) as totalsalary,
	count(*)as employees
from department d, employee e
where e.workdept = d.deptno 
group by deptno, deptname				
				\end{lstlisting}
				\end{ex}
				\lstinline|having| is like \lstinline|where| for groups
				\begin{ex}
					list average salary for each dept >= 4 people
					\begin{lstlisting}[language=SQL]
select deptno, deptname, avg(salary) as MeanSalary
	count(*)as employees
from department d, employee e
where e.workdept = d.deptno 
group by deptno, deptname
having count(*) >= 4
					\end{lstlisting}
				\end{ex}
	\subsection{DDL}
		\subsubsection{Table}
			\begin{description}
				\item[create]: creates a table
				\item[alter]: change the table
				\item[drop]: delete the table
			\end{description}
			\begin{ex}
				create table
				\begin{lstlisting}[language=SQL]
create table Employee (
EmpNo char(6),
FirstName varchar(12),
HireDate date
)				
				\end{lstlisting}
			\end{ex}
		\subsubsection{Data Types}
			\begin{multicols}{2}
				\begin{itemize}
					\item integer
					\item decimal(p,q)
					\item float(p)
					\item char(n)
					\item varchar(n): variable length
					\item date
					\item time
					\item timestamp: date + time
					\item year/month interval
					\item day/time interval
				\end{itemize}
			\end{multicols}
		\subsubsection{Constraints}
			\begin{itemize}
				\item not NULL
				\item primary key
				\item unique
				\item foriegn key
				\item column or tuple check
			\end{itemize}
			\begin{ex}
				add a start date that must come before hire date
				\begin{lstlisting}[language=SQL]
alter table Employee
add column StartDate date
add constraint hire_before_start
	check (HireDate <= StartDate);
				\end{lstlisting}
			\end{ex}
		\subsubsection{Triggers}
			\textbf{trigger}: procedure executed by the db in response to table change
			\begin{itemize}
				\item event
				\item condition
				\item action
			\end{itemize}
			\begin{lstlisting}[language=SQL]
create trigger log_addr
after update of addr, phone on person
referencing OLD as o NEW as n
for each row 
mode DB2SQL
when (o.status = 'VIP' or n.status = 'VIP')
	insert into VIPaddrhist(pid, oldaddr, oldphone,
		newaddr, newphone, user, modtime)
	values (o.pid, o.addr, o.phone,
		n.addr, n.phone, user, current timestamp)
			\end{lstlisting}
	\section{Views} 
		\subsection{Definition}
			\textbf{View}: a relation whose instance is determined by other relations
			\begin{itemize}
				\item \textbf{Virtual}: views not stored, used only for querying
				\item \textbf{Materialized}: query for view is executed and view is stored
			\end{itemize}
			\begin{lstlisting}[language=SQL]
create [materialized] view <name>
	as query
			\end{lstlisting}
			\begin{ex}
				Manufacturing projects view
				\begin{lstlisting}
create view ManufacturingProjects as
	( select projno, projname, firstname, lastname
	  from project, employee
	  where respemp = empno and deptno = 'D21' )
				\end{lstlisting}
			\end{ex}
		\subsection{Updating}
			Changes to a view schema propogate back to instances of relations in conceptual schema, so to avoid ambiguity a view is updateable if:
			\begin{itemize}
				\item the query references exactly one table
				\item the query only outputs simple attributes
				\item there is \textbf{no} grouping/aggregation/distinct
				\item there are no nested queries
				\item there are no set operations
			\end{itemize}
			Materialized views also have to be update with periodically to account for base table changes
		
	\section{Application Development}
		\subsection{Static Embedded SQL}		
			Embed SQL into C with \lstinline|EXEC SQL| and suffixing with \lstinline|;|, using host variables to send and recieve values from DB
			\begin{ex}
				Host variables in C
				\begin{lstlisting}[language=C]
EXEC SQL BEGIN DECLARE SECTION;
char deptno[4];
char deptname[30];
char mgrno[7];
char admrdept[4];
char location[17];
EXEC SQL END DECLARE SECTION;

/ * program assigns values to variables * /

EXEC SQL INSERT INTO
Department(deptno,deptname,mgrno,admrdept,location)
VALUES
(:deptno,:deptname,:mgrno,:admrdept,:location);
				\end{lstlisting}
			\end{ex}
			\textbf{indicator variables} are flags used to handle host variables that might recieve \lstinline|NULL|
			\begin{ex}
				Indicator variables
				\begin{lstlisting}[language=C]
int PrintEmployeePhone( char employeenum[] ) {
EXEC SQL BEGIN DECLARE SECTION;
	char empno[7];
	char phonenum[5];
	short int phoneind;
EXEC SQL END DECLARE SECTION;
	strcpy(empno,employeenum);
EXEC SQL
	SELECT phoneno INTO :phonenum :phoneind
	FROM employee WHERE empno = :empno;
if( SQLCODE < 0) { return( -1 ); } /* error */
else if(SQLCODE&=& 100){printf("no such employee\n");}
else if (phoneind<0){printf("phone unknown\n");}
else { printf("%s\n",phonenum); } 
return( 0 );
}]
				\end{lstlisting}
			\end{ex}
			\textbf{cursors}: pointer-like objects used to iterate when > 1 row is returned. Can be before the first tuple, on a tuple, after the last tuple.
			\begin{enumerate}
				\item declare the cursor
				\item open the cursor
				\item fetch tuples using the cursor
				\item close the cursor
			\end{enumerate}
		\subsection{Dynamic Embedded SQL}
			When tables, columns, predicates are not known at the time application is written
			\begin{enumerate}
				\item \lstinline|PREPARE|: prepare statement for execution
				\item \lstinline|EXECUTE|: execute the statement
				\item \textbf{placeholder}: appears instead of literals, host variables replace during execution
				\item \textbf{descriptor}: used to determine input and output numbers and types with \tt{DESCRIBE}
			\end{enumerate}
			\textbf{SQLJ}: allows embedding SQL into Java, with runtime established via JDBC connection
			\begin{ex}
				Host variables and placeholders
				\begin{lstlisting}[language=SQL]
EXEC SQL BEGIN DECLARE SECTION;
char s[100] = ``INSERT INTO employee VALUES (?, ?, ... )'';
char empno[7];
char firstname[13];
...
EXEC SQL END DECLARE SECTION;
EXEC SQL PREPARE S1 FROM :s;
strcpy(empno,``000111'');
strcpy(firstname,``Ken'');
...
EXEC SQL EXECUTE S1 USING :empno, :firstname, ... ;
				\end{lstlisting}
			\end{ex}
		\subsection{Call Level Interface}
			A vendor-neutral ISO-standard programming interface for SQL systems. As opposed to embedded SQL, does not need to be recompiled to access different DBMS and can access multiple at the same time
			\begin{itemize}
				\item queries represented as strings in the application
				\item queries prepared then executed
				\item app won't know numbers and types, descriptor areas hold metadata and actual data
				\item describing a query makes DBMS place type info into descriptor area which app can read
			\end{itemize}
		\subsection{Stored Procedure}
			Allows to execute application logic directly inside DBMS process
			\begin{itemize}
				\item minimize data transfer costs
				\item centralize application code
				\item logical independence
			\end{itemize}
			\begin{ex}
				\begin{lstlisting}[language=SQL]
CREATE FUNCTION sumSalaries(dept CHAR(3))
	RETURNS DECIMAL(9,2)
LANGUAGE SQL
RETURN
	SELECT sum(salary)
	FROM employee
	WHERE workdept = dept
				\end{lstlisting}
			\end{ex}

\end{document}

	
