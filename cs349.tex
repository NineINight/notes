\documentclass[]{article}
\usepackage{etex}
\usepackage[margin = 1.5in]{geometry}
\setlength{\parindent}{0in}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{color}
\usepackage{mathtools}
\usepackage{pgfplots}
\usepackage[lined]{algorithm2e}
\usepackage{qtree}
\usepackage{xytree}
\usepackage{float}
\usepackage{enumitem}
\usepackage[T1]{fontenc}
\usepackage{ae,aecompl}
\usepackage[pdftex,
  pdfauthor={Michael Noukhovitch},
  pdftitle={CS 349: User Interfaces},
  pdfsubject={Lecture notes from CS 349 at the University of Waterloo},
  pdfproducer={LaTeX},
  pdfcreator={pdflatex}]{hyperref}

\usepackage{cleveref}
\usepackage{enumitem}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4
}

\theoremstyle{definition}
\newtheorem*{defn}{Definition}
\newtheorem{ex}{Example}[section]
\newtheorem*{theorem}{Theorem}

\setlength{\marginparwidth}{1.5in}
\setlength{\algomargin}{0.75em}

\DeclarePairedDelimiter{\set}{\lbrace}{\rbrace}

\definecolor{darkish-blue}{RGB}{25,103,185}

\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=darkish-blue,
    filecolor=darkish-blue,
    linkcolor=darkish-blue,
    urlcolor=darkish-blue
}
\newcommand{\lecture}[1]{\marginpar{{\footnotesize $\leftarrow$ \underline{#1}}}}

\makeatletter
\def\blfootnote{\gdef\@thefnmark{}\@footnotetext}
\makeatother

\begin{document}
	\let\ref\Cref

	\title{\bf{CS 349: Algorithms}}
	\date{Winter 2015, University of Waterloo \\ \center Notes written from Michael Terry's lectures.}
	\author{Michael Noukhovitch}

	\maketitle
	\newpage
	\tableofcontents
	\newpage

	\section{Introduction}
		\subsection{Definitions}
			\textbf{Interface}: external presentation to user
			\begin{itemize}
				\item \textbf{controls}: manipulated to communicate intent
				\item \textbf{presentation}: what communicates response
			\end{itemize}
			\textbf{Interaction}: the actions a user must do to elicit corresponding response
			\begin{itemize}
				\item action and dialog
				\item unfolds over time
			\end{itemize}
	\section{Events}
		\subsection{Event Loop}
			\begin{lstlisting}
while(true) {
	if there is an event on queue:
		dequeue it 
		dispatch it
}
			\end{lstlisting}
		\subsection{Timer}
			Some events are triggered by a timer, if that event's execution time is longer than the timer interval 
			then by the end of the event execution, you should add another of your event to the queue!
		\subsection{Interactor Tree}			
			We need a way to send information about what object is clicked \\
			\textbf{interactor tree}: hierarchical tree-based organization of widgets
			\begin{itemize}
				\item each component's location is specified relative to parent
				\item we use \textbf{containers} whose sole purpose is to contain components
				\item events go \textbf{down} the tree to \textbf{capture} the target clicked
				\item event bubble \textbf{up} the tree to \textbf{handle} an event (e.g. EventListener)
			\end{itemize}
		\subsection{Event Propogation}
			when an event happens:
			\begin{enumerate}
				\item calculate the parent node path
				\item loop through it and execute capture phase handlers
				\item execute DOM level 1 phase handler
				\item execute bubble phase handlers 
				\item execute default browser behaviour
			\end{enumerate}
	\section{Model View Controller}
		\subsection{Idea}
			We decouple presentation from data using the \textbf{observer} design pattern. This separation allots benefits:
			\begin{itemize}
				\item \textbf{change the UI}: easy to change how we interact with data
				\item \textbf{multiple view}: have different views of same data
				\item \textbf{code reuse}: different logic for same view etc..
				\item \textbf{testing}: data separation allows better logic testing
			\end{itemize}
		\subsection{Description}
			\textbf{Model}: manages the data
			\begin{itemize}
				\item represent the data
				\item methods to manipulate data
				\item create and notify listeners
			\end{itemize}
			\textbf{View}: manages the presentation
			\begin{itemize}
				\item renders the data in a model
				\item references to the model
				\item is a listener to the model
			\end{itemize}
			\textbf{Controller}: manages user interaction
			\begin{itemize}
				\item between the model and view
				\item helps interpret input and model events
			\end{itemize}
	\section{Layout}
		\subsection{Layout Manager}
			\textbf{Layout Manager}: keeps the layout for components given their constraints and preferences
			\begin{itemize}
				\item uses composite and strategy design pattern
			\end{itemize}
			\subsubsection{Dynamic Layout}
				\textbf{Dynamic Layout}: maintain consistency with spatial layout
				\begin{itemize}
					\item reallocate space for widget
					\item adjust location and size
					\item change visibility, look, feel
				\end{itemize}			
			\subsubsection{Layout Strategies}
				\begin{itemize}
					\item \textbf{fixed layout}
					\item \textbf{intrinsic size}:	find each item's preferred size and the container will grow to perfectly contain each item
					\item \textbf{variable intrinsic size}:	layout determined in bottom-up and top-down phases
					\item \textbf{struts and spring}:	items can either be fixed (strut) or variable (spring)
				\end{itemize}
		\subsection{Responsive Design}
			\textbf{Responsive Design}: change layout to adapt to screen sizes of different devices
			\subsubsection{CSS}
				\textbf{CSS}:	specifying formatting
				\begin{itemize}
					\item consistency
					\item reduce size (cache CSS)
					\item code reuse
					\item separation of concerns
				\end{itemize}
				\textbf{CSS reset}:	normalize appearance across browsers
			\subsubsection{Cascade}
				Layout resolves CSS rules and renders following these rules:
				\begin{enumerate}
					\item find all declarations that match the element
					\item sort declarations by \lstinline|!important|
					\item sort by origin (author > web browser)
					\item sort by specificity of selector
					\item sort by order (later rule wins)
				\end{enumerate}
	\section{Visual Design}
		Impose as little thinking as possible on the user
		\subsection{Rules}
			\textbf{Simplicity}:
			\begin{itemize}
				\item facilitate recognition instead of recall
				\item use only the essentials
			\end{itemize}
			\textbf{Consistency}:
			\begin{itemize}
				\item exploit perceptual patterns
				\item avoid ambiguous presentation
				\item present information consistent with user goals
			\end{itemize}
			\textbf{Organization and Structure}:
			\begin{itemize}
				\item grouping
				\item hierarchy
				\item relationship
			\end{itemize}
		\subsection{Gestalt Principles}
			Theories of visual perception that describe how people organize groups
			\begin{itemize}
				\item \textbf{proximity}: elements associated with nearby elements
				\item \textbf{similarity}: visual similarity
				\item \textbf{common fate}: moving together 
				\item \textbf{continuity}: continuous forms are easy to percieve
				\item \textbf{closure}: see a complete figure even when info is missing
				\item \textbf{symmetry}
				\item \textbf{area}: visual field split into background and foreground
				\item \textbf{uniform connection}: connecting lines/regions 
				\item \textbf{alignment}
			\end{itemize}
	
	\section{Transformation}
		\subsection{Basics}
			\begin{description}[leftmargin=5em,style=nextline]		
				\item[translate] add scalar
					\begin{flalign*}
						\begin{bmatrix}
							1 & 0 & t_x \\
							0 & 1 & t_y \\
							0 & 0 & 1
						\end{bmatrix}
					\end{flalign*}
				\item[scale] multiply by scalar
					\begin{flalign*}
						\begin{bmatrix}
							s_x &0 & 0 \\
							0 & s_y & 0\\
							0 & 0 & 1
						\end{bmatrix}
					\end{flalign*}
				\item[rotate] $x' = x\cos \Theta - y\sin \Theta$ \\
				$y' = x\sin \Theta + y\cos \Theta$ 
					\begin{flalign*}
						\begin{bmatrix}
							\cos \Theta & -\sin \Theta & 0 \\
							\sin \Theta & \cos \Theta & 0\\
							0 & 0 & 1
						\end{bmatrix}
					\end{flalign*}
			\end{description}		

			\section{Widgets}
				\subsection{Definition}
					\begin{description}
						\item[Logical Input Device]: graphical component defined by its function/behaviour
						\item[Widget]: part of an interface that has its own behaviour
							\begin{itemize}
								\item the \textbf{model} manipulated by the widget
								\item the \textbf{events} generated by the widget
								\item the widget \textbf{properties} which change behaviour and appearance 
							\end{itemize}
					\end{description}
				\subsection{Types}
					\subsubsection{Simple Widgets}
						\begin{itemize}
							\item labels and images
							\item button
							\item boolean \textit{e.g. radio button}
							\item number \textit{e.g. slider} 	
							\item text field
						\end{itemize}
					\subsubsection{Container Widgets}
					\begin{itemize}
						\item pane
						\item tab
						\item menu
						\item list choice \textit{e.g. dropdown menu}
					\end{itemize}
					\subsubsection{Abstract Model Widgets}
						\dots
				\subsection{Widget Toolkit}
					\textbf{Widget Toolkit}: software that defines a set of (event-driven) GUI components via API 
					\begin{itemize}
						\item \textbf{complete}: GUI designers have all they need
						\item \textbf{consistent}: look, feel and usage paradigms are consistent
						\item \textbf{customizable}: devs can reasonably extend functionality
					\end{itemize}
					There are two common implementations of widgets:
					\begin{itemize}
						\item \textbf{Heavyweight widgets}: OS provides widgets and hierarchical windowing system \textit{e.g. X, HTML}
						\item \textbf{Lightweight widgets}: OS provides top-level window, use toolkit for drawing and events \textit{e.g. Java Swing}
					\end{itemize}
			\section{Responsiveness}
				\textbf{Responsiveness}: the fulfillment of a user's real-time needs
				\subsection{Human Deadline}
					Make your program seem faster by using tricks to respond to a user's actions:
					\begin{itemize}
						\item busy indicator
						\item progress indicator
						\item rendering important information first
						\item fake heavyweight computations \textit{e.g. scrolling}
						\item work ahead during periods of low load
					\end{itemize}
				\subsection{AJAX}
					Classic web architechture relied on	'thin client, fat architechture', side step it using JS:
					\begin{itemize}
						\item AJAX issues call to web server (API)
						\item server handles request and returns data feed 
						\item client updates UI with feed using JS
					\end{itemize}
					Advantages:
					\begin{itemize}
						\item minimize bandwidth
						\item increase speed
						\item avoid HTML headers 
					\end{itemize}
					\begin{ex}
						AJAX backend using Bottle (Python)
						\begin{lstlisting}[language=Python]
from bottle import route, run, template, request

@route('/ajax', method='POST')
def ajax():
	# Retrieve the JSON
	json_data = request.json

	# upper-case and return the text
	upper = json_data['text'].upper()

	# Bottle will automatically send back
	# Python dictionaries as JSON objects
	return {'reply': upper}
						\end{lstlisting}
					\end{ex}
			\section{Design Process}
				We need to have descriptions of UI to clarify intent and \textbf{define interaction}. 
				\subsection{Formal Language}
				The design process can be strongly described with formal languages such as \textbf{Finite State Machines} allowing us to label states and transitions. But this rigid formality has troubles describing the rich informal world of the user:
				\begin{itemize}
					\item complexity of interfaces is too great
					\item can't clearly represent some ideas \textit{e.g. timed events}
					\item transition time (to create/update model) is not negligable
				\end{itemize}
				\subsection{User Centered Design}
					Design (and test) with real people in mind, using semi-formal languages
					\begin{itemize}
						\item understand user needs
						\item design UI first (then architecture)
						\item iterate
						\item use it yourself
						\item observe others using it
					\end{itemize}
					This can be put into a design process:
					\subsubsection{Understand the User}
						\begin{itemize}
							\item observe existing solutions
							\item list scenarios
							\item list functions required
							\item prioritize (freq and commonality)
						\end{itemize}
					\subsubsection{Design the UI}
						\begin{itemize}
							\item identify and design components
							\item design component distributions
								\begin{itemize}
									\item storyboards
									\item interaction sequeunces: macro structure
									\item interface schematics: micro structure
								\end{itemize}
							\item test the design with users
								\begin{itemize}
									\item prototyping (high vs low fi, paper, Wizard of Oz)
									\item user/usability studies
								\end{itemize}
							\item iterate again!
							\item document the design
								\begin{itemize}
									\item visual vocabulary
								\end{itemize}
						\end{itemize}
					\subsubsection{Refine the Design}
						\begin{itemize}
							\item refine requirements
							\item add new scenarios
							\item walk through new scenarios
							\item adjust UI design
						\end{itemize}


				
\end{document}
