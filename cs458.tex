\documentclass[]{article}
\usepackage{etex}
\usepackage[margin = 1.5in]{geometry}
\setlength{\parindent}{0in}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{color}
\usepackage{mathtools}
\usepackage{multicol}
\usepackage{pgfplots}
\usepackage{qtree}
\usepackage{xytree}
\usepackage[lined]{algorithm2e}
\usepackage{float}
\usepackage[T1]{fontenc}
\usepackage{ae,aecompl}
\usepackage[pdftex,
  pdfauthor={Michael Noukhovitch},
  pdftitle={CS 458: Computer Security and Privacy},
  pdfsubject={Lecture notes from CS 458 at the University of Waterloo},
  pdfproducer={LaTeX},
  pdfcreator={pdflatex}]{hyperref}

\usepackage{cleveref}
\usepackage{enumitem}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4
}

\theoremstyle{definition}
\newtheorem*{defn}{Definition}
\newtheorem{ex}{Example}[section]
\newtheorem*{theorem}{Theorem}

\setlength{\marginparwidth}{1.5in}
\setlength{\algomargin}{0.75em}

\DeclarePairedDelimiter{\set}{\lbrace}{\rbrace}

\definecolor{darkish-blue}{RGB}{25,103,185}

\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=darkish-blue,
    filecolor=darkish-blue,
    linkcolor=darkish-blue,
    urlcolor=darkish-blue
}
\newcommand{\lecture}[1]{\marginpar{{\footnotesize $\leftarrow$ \underline{#1}}}}

\makeatletter
\def\blfootnote{\gdef\@thefnmark{}\@footnotetext}
\makeatother

\begin{document}
	\let\ref\Cref

	\title{\bf{CS 458: Computer Security and Privacy}}
	\date{Spring 2016, University of Waterloo \\ \center Notes written from Erinn Atawater's lectures.}
	\author{Michael Noukhovitch}

	\maketitle
	\newpage
	\tableofcontents
	\newpage

	\section{Introduction}
	\subsection{Security}
	Security can be defined as:
	\begin{description}
		\item[confidentiality] access to systems is limited to authorized
		\item[integrity] getting the correct data
		\item[availability] system is there when you want it
	\end{description}
	\subsection{Privacy}
	There are many definitions but we will stick to \textbf{informational self-determination}, where you control the information about you

	\subsection{Terminology}
	\begin{description}
		\item[assets] things we want to protect
		\item[vulnerabilities] weaknesses in a system that can be exploited
		\item[threats] loss or harm that may befall a system
			\begin{itemize}
				\item interception
				\item interruption
				\item modification
				\item fabrication
			\end{itemize}
		\item[threat model] set of threats to defend against (who/what)
		\item[attack] an action which exploits a vulnerability to execute a threat
		\item[control] removing or reducing a vulnerability
	\end{description}

	\subsection{Types of Defence}
	Defend against an attack:
	\begin{itemize}
		\item \textbf{prevent} stop the attack from happening
		\item \textbf{deter} make the attack more difficult
		\item \textbf{deflect} make it less attractive for attacker
		\item \textbf{recover} mitigate effects of the attack
	\end{itemize}

	Make sure that defence is correct with principles:
	\begin{itemize}
		\item \textbf{easiest penetration} system is only as strong as weakest link
		\item \textbf{adequate protection} don't spend more on defence than the value of the system
	\end{itemize}

	\subsection{Methods of Defence}
	\begin{itemize}
		\item Software controls: passwords, virus scanner \dots
		\item Hardware controls: fingerprint reader, smart token \dots
		\item Physical controls: locks, guards, backups \dots
		\item Policies: teaching employees, password changing rules
	\end{itemize}


	\section{Program Security}
	\subsection{Flaws, faults, and failures}
	\subsubsection{Defintions}
	\begin{description}
		\item[flaw] problem with a program
		\item[fault] a potential error inside the logic
		\item[failure] an actual error visible by the user
	\end{description}
	\subsubsection{Unexpected Behaviour}
	A spec will list the things a program will do but an implementation may have additional behaviour. 
	This can cause issues as these behaviours might not be tested and would be hard to test.

	\subsection{Unintentional Security Flaws}
	\subsubsection{Types of Flaws}
	\begin{itemize}
		\item \textbf{intentional}
			\begin{itemize}
				\item \textbf{malicious}: inserted to attack system
				\item \textbf{nonmalicious}: intentional features meant to be in the system but can cause issues
			\end{itemize}
		\item most flaws are \textbf{unintentional}
	\end{itemize}
	\subsubsection{Buffer Overflow}
	Most common exploited type of security flaw when program reads or writes past the bounds of the memory that it should use. If the attacker exploits it they can override things like the \textit{saved return address}. Targets programs on a local machine that run with setuid priveleges or network daemons
	
	\begin{ex}
		basic buffer overflow
	\begin{lstlisting}[language=C]
#define LINELEN 1024

char buffer[LINELEN];
strcpy(buffer, argv[1]);
	\end{lstlisting}
	\end{ex}
	
	\textbf{Types}:
	\begin{itemize}
		\item only a single byte can be written past the end of the buffer
		\item overflow of buffers on the heap (instead of the stack)
		\item jump to other parts of the program or libraries (instead of shellcode)
	\end{itemize}

	\textbf{Defences}:
	\begin{itemize}
		\item language with bounds-checking
		\item non-executable stack (mem is never both writable and executable)
		\item stack at random virtual addresses for each process
		\item ``canaries'' detect if stack has been overwritten before return
	\end{itemize}

	\subsubsection{Integer Overflows}
	Program may assume integer is always positive, and below certain value. Overflow will make a too large singed integer negative, violating assumptions.

	\subsubsection{Format String Vulnerabilities}
	Format strings can have unexpected consequences, \lstinline|printf|
	\begin{itemize}
		\item \texttt{buffer} parse buffer for \lstinline|\%|s and use whatever is on the stack to process found format params
		\item \texttt{\%s\%s\%s\%s} may crash your program
		\item \texttt{\%x\%x\%x\%x} dumps parts of the stack
		\item \texttt{\%n} will write to an address on the stack
	\end{itemize}

	\subsubsection{Incomplete Mediation}
	\begin{description}
		\item[mediation] ensure what the user has entered is a meaningful request
		\item[incomplete mediation] application accepts incorrect user data
	\end{description}
	Though \textbf{client-side} mediation is helpful to the user, you should always perform \textbf{server-side} mediation
	\begin{itemize}
		\item check values entered by user
		\item check state stored by client
	\end{itemize}
	\begin{description}
		\item[TOCTTOU] ``time of check to time of user'' errors are race conditions that may affect correct access to resources
	\end{description}
	Defend by making all access control information \textbf{constant} between TOC and TOU
	\begin{itemize}
		\item keep private copy of request
		\item act on object itself as opposed to symlinks \dots
		\item use locks on object
	\end{itemize}

	\subsection{Malware}
	\begin{itemize}
		\item written with malicious intent
		\item needs to executed to cause harm
	\end{itemize}

	\subsubsection{Virus}
	\begin{description}
		\item[virus] malware that infects other files (with copies of itself)
		\item[infect] modify existing program (\textit{host}) so opening gives control to virus
		\item[payload] end goal of virus (e.g. corrupt, erase \dots)
	\end{description}

	Protection can come in two forms:
	\begin{description}
		\item[signature-based] keep a list of all known viruses (but how to deal with polymorphic viruses?)
		\item[behaviour-based] look for suspicious system behaviour
	\end{description}

	\subsubsection{Worm}
	\begin{description}
		\item[worm] self-containing piece of code that replicated with little/no user input
	\end{description}
	\begin{itemize}
		\item often use security flaws in widely deployed software
		\item searches for other unprotected sources to spread to
	\end{itemize}

	\subsubsection{Other Types}
	\begin{description}
		\item[trojan horse] claim to do something normal, but hide malware
		\item[scareware] scaring user into agreeing
		\item[ransomware] ransoming user's resource
		\item[logic bomb] written by insider, already on your computer waiting to be triggered
	\end{description}

	\subsection{Other Malicious Code}
	\subsubsection{General Attacks}
	\begin{description}
		\item[web bug] tiny object in web page, fetched from a different server that can track you
		\item[backdoor] instructions set to bypass normal authentication, come from
	\end{description}
	\begin{itemize}
		\item forgetting to remove
		\item testing purposes
		\item law enforcement
		\item malicious purposes
	\end{itemize}
	\begin{description}
		\item[salami attack] attack from many smaller attacks
		\item[privelege escalation] raises privelege of attacker, can cause legitimate higher privelege code to execute attack
		\item[rootkit] tool to gain priveleged access and then hide itself
	\end{description}
	\begin{itemize}
		\item cleans logs
		\item modify basic commands \lstinline|ls|\dots
		\item modify kernel so no programs can see it
	\end{itemize}

	\subsubsection{Man-in-the-middle}
	intercepts communication but passes it on to intended party eventually
	\begin{description}
		\item[keystroke logger] logs keyboard input and spies on user
	\end{description}
	\begin{itemize}
		\item application-specific
		\item system logger (all keystrokes)
		\item hardware logger (physical device)
	\end{itemize}
	\begin{description}
		\item[interface illusions] tricks user to execute malicious action with UI
			\begin{description}
				\item[phishing] make fake website look real to extract user information
			\end{description}
	\end{description}

	\subsection{Nonmalicious flaws}
	\begin{description}
		\item[covert channels] transfer data through secret/non-standard channel (e.g. hide data in published report)
		\item[side channels] attack based on knowledge from physical behaviour of computer 
	\end{description}
	\begin{itemize}
		\item RF emissions
		\item power consumption
		\item cpu usage
		\item reflection of the screen
	\end{itemize}

	\subsection{Security Controls}
	\subsubsection{Design}
	Design programs so they're less likely to have flaws
	\begin{itemize}
		\item modularity
		\item encapsulation
		\item information hiding
		\item mutual suspicion
		\item confinement/sandboxing
	\end{itemize}

	\subsubsection{Implementation}
	When actually coding, reduce security flaws
	\begin{itemize}
		\item don't use C
		\item static code analysis
		\item formal methods
		\item genetic diversity (run varied code)
		\item educate yourself
	\end{itemize}

	\subsubsection{Change Management}
	Make sure that all changes to the code maintain security
	\begin{itemize}
		\item track changes in a system (CVS \dots)
		\item do post-mortems of security flaws
		\item code reviews
			\begin{itemize}
				\item guided code reviews
				\item easter-egg code reviews (intentional flaws)
			\end{itemize}
	\end{itemize}

	\subsubsection{Testing}
	Make sure implementation meets specification \textit{and nothing else}
	\begin{description}
		\item[black box testing] treat code as an opaque interface
		\item[fuzz testing] submit completely random data
		\item[white box testing] testing which understands how it works, good for regression testing
	\end{description}

	\subsubsection{Documentation}
	For posterity, write down:
	\begin{itemize}
		\item choices made
		\item things that didn't work
		\item security checklist
	\end{itemize}

	\subsubsection{Maintenance}
	Make sure that code out there gets better not worse
	\begin{description}
		\item[standards] rules to incorporate controls at each software stage
		\item[process] formal specs of how to implement each standard
		\item[audits] externally verify your processes are correct and followed
	\end{description}

	\section{Operating System Security}
	\subsection{Protection in a General-Purpose System}
	\subsubsection{Overview}
	Protect a user from attacks, and protect resources:
	\begin{itemize}
		\item CPU
		\item memory
		\item I/O devices
		\item programs
		\item data
		\item networks
		\item OS
	\end{itemize}

	\subsubsection{Separation/Sharing}
	Keep one users' objects separate from others'
	\begin{itemize}
		\item \textbf{physical} use different physical resource
		\item \textbf{temporal} execute at different times
		\item \textbf{logical} give impression that no other users exist
		\item \textbf{cryptographic} enrypt data to make it unintelligible
	\end{itemize}
	OS' can allow for \textbf{flexible sharing}, not ``all or nothing''
	\subsubsection{Memory Protection}
	Prevent one program from corrupting other programs, OS, data\dots
	\begin{description}
		\item[fence register] exception if memory access below address in fence register
		\item[base/bounds register pair] exception if memory not between register pair
		\item[tagged architechture] each memory word has extra bits that identify access to that word
	\end{description}
	
	\subsubsection{Segmentation}
	\textbf{segmentation} each program has different mem segments for code, data, stack.
	 Virtual address contains \lstinline|<segment name, offset within segment>| and segment name is mapped to physical address in \textit{Segment Table}
	\begin{itemize}
		\item[+] each address reference is checked for protection
		\item[+] different levels of protection
		\item[+] share/restrict access to a segment
		\item[-] external fragmentation
		\item[-] costly: dynamic length out-of-bounds checks, segment names
	\end{itemize}

	\subsubsection{Paging}
	\begin{description}
		\item[pages] equal divisions of virtual address space
		\item[frames] equal divisions of physical memory (size same as page)
		\item[page table] maps page number to corresponding frame \lstinline|<page #, offset within page>|, also contains memory protection bits for each page
	\end{description}
	\begin{itemize}
		\item[+] each address reference is checked for protection
		\item[+] share/restrict access to a page with different rights
		\item[+] unpopular pages can be moved to disk
		\item[-] internal fragmentation
		\item[-] infeasible to have different levels of protection for different data
	\end{itemize}

	\subsubsection{x86}
	Includes both segmentation and paging, with memory protection bits:
	\begin{itemize}
		\item no access
		\item read access
		\item read/write access
		\item *no execute
	\end{itemize}

	\subsection{Access Control}
	\subsubsection{Overview}
	We need to protect more than just memory, with three goals
	\begin{itemize}
		\item check every access
		\item enforce least privelege
		\item verify acceptable use
	\end{itemize}

	Create an \textbf{access control matrix} for a set of protected objects $0$, subjects $S$, and rights $R$ (r,w,x,o).

	\subsubsection{Access Control Methods}
	\begin{description}
		\item[Access Control Lists] each object has a list of subjects and their access rights
		\item[Capability] unforgeable token that gives own some access rights to an object
		\item[RBAC] admin assign users to roles and grants access rights to roles
	\end{description}
	\begin{itemize}
		\item can be hierarchical
		\item a user can have multiple roles for different tasks
		\item \textbf{separation of duty} same person can't be responsible for two different roles on a task
	\end{itemize}
	
	\subsection{User Authentication}
	\subsubsection{Overview}
	Computers systems have to identify and authenticate users before authorizing them
	\begin{description}
		\item[identify] who are you
		\item[authenticate] prove your identify
	\end{description}
	\subsubsection{Authentication Factors}
	Four classes, something the user:
	\begin{itemize}
		\item \textbf{knows} password, PIN
		\item \textbf{has} ATM card, physical key
		\item \textbf{is} biometrics
		\item \textbf{context} location, time
	\end{itemize}
	Using multiple factors (``two-factor'' authentication) improves security if they are different types

	\subsubsection{Passwords}
	Attacks:
	\begin{itemize}
		\item shoulder surfing
		\item keystroke logging
		\item phishing
		\item password re-use
		\item password guessing
	\end{itemize}

	User defenses:
	\begin{itemize}
		\item choosing good passwords (long and not easily guessable)
		\item hygiene
			\begin{itemize}
				\item write down > store insecurely
				\item change regularly
				\item site specific passwords
				\item don't reveal
				\item don't enter sensitive info on public computers
			\end{itemize}
	\end{itemize}

	Admin defenses:
	\begin{itemize}
		\item store only cryptographic hashes
			\begin{description}
				\item[salt] user-specific addition to hash (based on time of day \dots)
				\item[pepper] salt not stored alongside password
			\end{description}
		\item use expensive hash
			\begin{itemize}
				\item SHA-x take microseconds
				\item bcrypt takes hundreds of milliseconds
				\item scrypt also uses a lot of memory
			\end{itemize}
		\item use a \textbf{MAC} message authentication code
			\begin{itemize}
				\item also uses secret key to compute fingerprint
				\item impossible to crack without secret key
				\item as secure as hashing if key does leak
			\end{itemize}
		\item make password recovery force a reset
			\begin{itemize}
				\item don't email them the password, since you shouldn't be storing it
			\end{itemize}
		\item one-time passwords
			\begin{itemize}
				\item fight interception attacks 
				\item \textbf{challenge-response} to generate the password
			\end{itemize}
	\end{itemize}

	\subsubsection{Biometrics}
	Authenticate user if \textit{physical characteristic} is sufficiently similar to stored trait, but this has issues
	\begin{itemize}
		\item remote authentication can't test if you are trying to bypass it
		\item since we check for similarity, not equality, false positives are more likely
		\item facial recognition software still not good enough for security
		\item privacy issue if your stored biometrics leak
		\item if leaked, you can change a password, but not biometrics
		\item some of your biometrics are not secret (easy to get photos of\dots)
	\end{itemize}

	\subsection{Security Policies and Models}
	\subsubsection{Trusted OS}
	We trust an OS if we have confidence that it provides security services which build on four factors:
	\begin{description}
		\item[policy] set of rules outlining what is secured and why
		\item[model] implementes the policy and can be used for reasoning about it
		\item[design] spec of how OS implements model
		\item[trust] assurance that OS is implemented according to design
	\end{description}

	\subsubsection{Trusted Software}
	Software that does what we expect it to do and nothing more
	\begin{description}
		\item[functional correctness] software works correctly
		\item[enforcement of integrity] wrong inputs don't impact correctness
		\item[limited privelege] access rights are minimized
		\item[appropriate confidence level] rated as required 
	\end{description}

	\subsubsection{Security Policies}
	Basic military model:
	\begin{itemize}
		\item each object has a sensitivity level
		\item each object is assigned to one or more compartments
		\item subject can access if it \textit{dominates} the requirements
	\end{itemize}

	\begin{description}
		\item[Chinese Wall] security policy that once you access info you can't access info about competitors
		\item[ss-property] read access by subject to object if each object previously accessed is either from the same company, or a different type of company (no conflict)
		\item[*-property] write access by subject to object if all readable object by subject are either from the same company or have been \textit{sanitized} 
		\item[lattice] security model where there is a unique upper and lower bound for any two points, i.e. each level is distinct
	\end{description}

	\subsubsection{Security Models}
	\textbf{Bell-La Padula} regulates information flow in lattices, so users get information only with their clearance
	\begin{itemize}
		\item no read up (read more secure documents)
		\item no write down (write less secure documents)
	\end{itemize}
	\textbf{Biba} prevent inappropriate modification of data
	\begin{itemize}
		\item subjects and objects ordered by integrity
		\item no read down (don't contaminate reliable person with unreliable info)
		\item no write up (don't contaminate reliable info with unreliable person)
	\end{itemize}
	\textbf{Low Watermark Property} instead of enforcing integrity rules, just reduce integrity when it is violated
	\begin{itemize}
		\item \textbf{subject} if subject $s$ reads object $o$, then $I(s) = $ greatest lower bound of $I(s)$ and $I(o)$
		\item \textbf{object} if a subject writes to an object, the reduce integrity of object to greatest lower bound
	\end{itemize}

	\subsection{Trusted OS Design}
	\subsubsection{Security Design Principles}
	\begin{description}
		\item[least privelege] use least priveleges possible
		\item[economy of mechanism] protection mechanism should be simple
		\item[open design] avoid security by obscurity (secret keys not algorithms)
		\item[complete mediation] check everything
		\item[permission based] default is no permissions
		\item[separation of priveleges] two or more conditions to get access
		\item[ease of use] make it easy or no one will use it
	\end{description}

	\subsubsection{Security Features}
	\textbf{identification/authentication}
	\textbf{access control}
	\begin{itemize}
		\item mandatory: central authority determines access
		\item directionary: owners of objects have some control over who can access
		\item role-based: central authority defines roles
	\end{itemize}
	\textbf{object reuse protection}
	\begin{itemize}
		\item stored data should be inaccessible to next user
		\item deleting a file should actually wipe it (not hidden!)
	\end{itemize}
	\textbf{complete mediation}
	\begin{itemize}
		\item all accesses must be checked
	\end{itemize}
	\textbf{trusted path}
	\begin{itemize}
		\item defend against illusions
		\item assure that keystrokes and mouse movements are sent correctly
	\end{itemize}
	\textbf{accountability and audit}
	\begin{itemize}
		\item log all security-related events
		\item find good middle-ground for granularity of logs
	\end{itemize}
	\textbf{intrusion detection}
	\begin{itemize}
		\item correlated actual behaviour with ``normal'' behaviour
		\item alarm if behaviour looks abnormal
	\end{itemize}

	\subsubsection{Trusted Computing Base}
	\begin{description}
		\item[TCB] part of the trusted OS that is necessary to enforce OS policies
		\item[security kernel] runs between OS and hardware maintaining security
		\item[rings] security level where processes can only access rings that level or above
		\item[reference monitor] monitor with collection of access controls that must be tamperproof, unbypassable, and analyzable
		\item[virtualization] way to provide logical separation/isolation
	\end{description}
	\begin{itemize}
		\item memory: page mapping to give separate address space
		\item machines: virtualize I/O, files, printers \dots
	\end{itemize}

	\subsubsection{Least Privelege}
	\begin{description}
		\item[chroot] sandbox/jail a command by changing its root directory
		\item[compartmentalization] split application into parts and apply least privelege to each part
		\item[setuid bit] causes executable to run under identity of owner not caller
	\end{description}
	\begin{itemize}
		\item careful of \textbf{confused deputy} attack where you convince program another user is executing a setuid'd program
	\end{itemize}

	\subsubsection{Assurance}
	Convince others to trust out OS through
	\begin{itemize}
		\item testing
		\item formal verification
		\item validation (requirements \dots)
	\end{itemize}

	Can also have third party evaluate it based on
	\begin{itemize}
		\item \textbf{Orange Book} security ratings from DoD
		\item \textbf{common criteria} international effort, protection profiles against security threats and objectives
	\end{itemize}


	\section{Network Security}
	\subsection{Network Concepts}
	\subsubsection{Overview}
	Internet has
	\begin{itemize}
		\item decentralized control
		\item uncontrollable traffic flow through different nodes
		\item different types of nodes/links
	\end{itemize}
	TCP/IP suite covers
	\begin{itemize}
		\item network access: ethernet, wifi \dots
		\item internet: network, IP \dots
		\item transport: TCP, UDP \dots
		\item application: HTTP, FTP, SSL \dots
	\end{itemize}
	Protocols were based on \textit{trust} and \textit{non-malicious} intent
	\subsection{Threats}
	\subsubsection{Port Scan}
	Each application runs on a \textbf{port} and unsecure systems (\textbf{loose lips}) can reveal what is running on each port, allowing the attacker to target weakest application
	\begin{itemize}
		\item nmap tool can identify application
		\item login application can reveal OS, version \dots
	\end{itemize}
	\subsubsection{Intelligence}
	Find information out in the open:
	\begin{itemize}
		\item social engineering
		\item dumpster diving
		\item eavesdropping 
		\item google searching
		\item facebook searching
	\end{itemize}

	\subsubsection{Wiretapping}
	Owner of a node can mointor all communication through it
	\begin{itemize}
		\item copper cable
			\begin{itemize}
				\item inductance allows for eavesdropping without physical contact
				\item cable cutting splicing otherwise
			\end{itemize}
		\item fiber optic
			\begin{itemize}
				\item no inductance, and splicing is possible but maybe detectable
				\item cable ``bending''
			\end{itemize}
		\item satellite
			\begin{itemize}
				\item signal path is wide so nearby attacker can eavesdrop
			\end{itemize}
		\item wifi
			\begin{itemize}
				\item easily intercepted nearby or far away using directed antenna
				\item need authentication for basic security
			\end{itemize}
		\item LAN
			\begin{itemize}
				\item attacker can un-ignore wrongly delivered packets using a \textbf{packer sniffer}
			\end{itemize}
	\end{itemize}

	\subsubsection{Impersonation}
	Impersonate by stealing a password
	\begin{itemize}
		\item guessing
		\item exploit default password
		\item sniff for password between nodes
		\item social engineering
	\end{itemize}
	and exploit trust beween machines and accounts where \lstinline|rhosts/rlogin| can allow another use on another machine to act as themselves on their machine without having to enter a password

	\subsubsection{Spoofing}
	\textbf{spoofing} when one object masquerades as another
	\begin{itemize}
		\item \textbf{url spoofing} uwaterlo.ca
		\item \textbf{evil twin} attacks wifi access points using the same name
		\item \textbf{session hijacking} stealing cookies or session key to hijack
		\item \textbf{man-in-the-middle} attacker becomes stealth intermediate node
	\end{itemize}

	\subsubsection{Traffic Analysis}
	Discovering the \textit{existance} of communication between two parties (e.g. whistleblower) can be sensitive, and can be discovered by attacker looking at send and recieve addresses in headers

	\subsubsection{Integrity Attacks}
	Modify packets as they are being transmitted
	\begin{itemize}
		\item change payload
		\item change sender/reciever
		\item replay previously seen packets (``buy 10 stocks'' over and over)
		\item delete or create packets
		\item TCP will can use a checksum but that can be easily defeated
	\end{itemize}
	Poison DNS cache
	\begin{itemize}
		\item feed wrong mappings to system redirecting them to your address
		\item DNNSEC created to combat this
	\end{itemize}

	\subsubsection{Protocol Failures}
	TCP and other protocols can be attacked directly:
	\begin{itemize}
		\item assumes all nodes implement protocol faithfully
		\item optional requests of systems to help flow control (can be ignored)
		\item may not check if packet is well formatted
		\item may include broken security mechanisms (e.g. WEP)
	\end{itemize}

	\subsubsection{Website Vulnerabilities}
	\begin{itemize}
		\item website defacement
		\item send malicious URL to web server (to exploit)
		\item submit modified state (cookie, session id) to exploit incomplete mediation
		\item code injection
			\begin{description}
				\item[XSS] steal sensitive information on page and send it to attacker
				\item[CSRF] perform malicious action on some website (e.g. bank) if user is logged in there
			\end{description}
	\end{itemize}

	\subsubsection{Denial of Service}
	\begin{itemize}
		\item cutting a wire, jamming a signal
		\item \textbf{ping flood} overload ability to respond to pings
		\item \textbf{smurf attack} spoof sender of ping as victim, and have return pings all go there
		\item \textbf{syn flood} overflow memory with stored SYN packets
		\item send packet fragments that can't be assembled
		\item send packets that are all hashed into same bucket
		\item \textbf{black hole attack} router advertises very low cost for destination and then drops all packets
		\item \textbf{DNS cache poisoning} make packets route to wrong host
	\end{itemize}

	\subsubsection{Distributed Denial of Service}
	DDoS makes it difficult to stop the source of the attack by using lots of machines
	\begin{description}
		\item[zombie/bot] computer controlled with malware
		\item[botnet] network of computers used to DDoS
		\item[amplification] use nodes that respond with more data than they are queried
		\item[reflection] send queries with victim's address as source
		\item[SNMP] simple network management protocol on many home routers which is usually vulnerable
	\end{description}
	Botnets can be controlled in many ways:
	\begin{itemize}
		\item central node: all bots connect and it gives commands
		\item p2p distributing updates
		\item fast flux: single host name maps to hundreds of addresses, constantly swap in/out of DNS to make tracking difficult
		\item domain generation algorithm: generate a large set of domain and contact a tue subset of them for instructions
	\end{itemize}

	\subsubsection{Active Code}
	Server can ask client to execute code on its behalf
	\begin{itemize}
		\item Java
		\item Javascript
		\item ActiveX
		\item Flash
	\end{itemize}
	Can be dangerous depending on sandboxing, ``trusted'' source

	\subsection{Network Security Controls}
	\subsubsection{Segmentation and Separation}
	\begin{itemize}
		\item have servers on different machines
		\item segment by functional and access requirements
		\item split by vulnerability (inside/outside firewall)
	\end{itemize}

	\subsubsection{Redundancy}
	\begin{itemize}
		\item avoid single points of failure
		\item different software, genetic diversity
		\item sync redundant servers closely (so they can easily take over)
	\end{itemize}

	\subsubsection{Access Controls}
	\begin{itemize}
		\item router ACL: drop packets with particular source and address
			\begin{itemize}
				\item expensive for high traffic
				\item difficult to gather logs
				\item source addresses can be spoofed
			\end{itemize}
		\item firewalls: filter based on other critera than addresses
	\end{itemize}

	\subsection{Firewalls}
	\subsubsection{Overview}
	\begin{itemize}
		\item all traffic goes through these choke points, \textbf{firewalls}
		\item carefully examine traffic, possibly refuse it access
		\item does not protect against attacks from inside
	\end{itemize}

	\subsubsection{Types}
	\begin{description}
		\item[packet filtering gateways] make decision based on header of a packet, can drop spoofed traffic
		\item[stateful inspection] keep state to identify packets that belong together
		\item[application proxies] app-specific firewall with full knowledge about communication and sophisticated processing
		\item[forward proxy] accessing server outside the company
		\item[reverse proxy] accessing company from outside
		\item[personal] home computer with a whitelist, protect against attacks on servers
		\item[Demilitarized Zone] subnet containing external services with internal and exteranl firewall
	\end{description}

	\subsection{Honeypots}
	\subsubsection{Overview}
	\begin{itemize}
		\item set up unprotected computer as a trap for attacker
		\item computer should have no activity
		\item monitor for any activity as sign of break-in
		\item continue monitoring honeypot to learn about new threats
	\end{itemize}

	\subsubsection{Types}
	\textbf{low interaction} daemon that emulates running host(s)
	\begin{itemize}
		\item[+] easy to install/maintain
		\item[-] limited amount of information gathered
		\item[-] easier to detect
	\end{itemize}
	\textbf{high interaction} deploy real hardware/software, tracking with stealth network switches and keyloggers
	\begin{itemize}
		\item[+] can capture lots of information
		\item[+] can caputure unexpected behaviour
		\item[-] complex
	\end{itemize}

	\subsection{Intrusion Detection Systems}
	\subsubsection{Overview}
	\textbf{IDS} monitor activity to identify malicious events
	\begin{itemize}
		\item recieve events from sensors
		\item store and analyze
		\item take action
	\end{itemize}

	\subsubsection{Host-based}
	Run on a host to protect this host
	\begin{itemize}
		\item[+] can exploit lots of information
		\item[-] miss out on information of other hosts
		\item[-] if host gets subverted, so does IDS (single point of failure)
	\end{itemize}

	\subsubsection{Network-based}
	Run on a dedicated node to protect all attached hosts
	\begin{itemize}
		\item[+] difficult to subvert
		\item[-] has to rely on information available in packets
	\end{itemize}
	\textbf{Distributed IDS} combination of host-based and network-based

	\subsubsection{Signature-based}
	Detect attack ``signatures''
	\begin{itemize}
		\item[+] may exploits statistical analysis to catch tough stuff
		\item[-] may fail if attacker modifies attack (polymorphic worms)
	\end{itemize}

	\subsubsection{Heuristic/Anomaly-based}
	Look for behaviour that is out of the ordinary
	\begin{itemize}
		\item model good behaviour and alert if system doesn't follow model
		\item model bad behaviour and alert if system resembles model
		\item classify as 
			\begin{itemize}
				\item good
				\item suspicious
				\item unknown
			\end{itemize}
		\item learn to classify unknown events over file
	\end{itemize}
	





	\section{Internet Application Security and Privacy}
	\subsection{Cryptography}
	\subsubsection{Overview}
	\begin{description}
		\item[cryptanalysis] breaking secret messages
		\item[cryptography] making secret messages
	\end{description}
	\begin{itemize}
		\item confidentiality: prevent eavesdropping
		\item integrity: prevent message modification
		\item authenticity: prevent impersonation
	\end{itemize}

	\subsubsection{Kerckhoffs Principle}
	The security of a cryptosystem should not rely on a secret that's hard (or expensive) to change
	\begin{itemize}
		\item no secret encryption \textit{methods}
		\item large class of encryption methods
		\item make the class public information
		\item use a secret key to specify which one
		\item system only as secure as number of keys
	\end{itemize}
	
	\subsubsection{Attacker's Information}
	The attacker (eavesdropping) may know
	\begin{itemize}
		\item algorithm (public class of encryption method)
		\item some part of the plaintext
		\item corresponding plaintext/cipher pairs
		\item access to encryption/decryption oracle
	\end{itemize}
	
	\subsection{Secret-key Encryption}
	\subsubsection{Overview}
	\begin{description}
		\item[symmetric encryption] same key used to encrypt is used to decrypt
		\item[one-time pad] key is random bitstring same length as plaintext, XOR'd, used only once
	\end{description}
	Need a secure medium to share the secret key between two parties

	\subsubsection{Computational Security}
	Most security is ``imperfect'' and can be cracked with enough effort: trying every key
	\begin{itemize}
		\item 40-bit crypto: old US legal export limit, 18 hours on 1 computer
		\item 56-bit crypto: DES, 134 years
		\item 128-bit crypto: modern standard, $635*10^{21}$ years
	\end{itemize}

	\subsubsection{Ciphers}
	\textbf{stream cipher} pseudorandom key used to XOR plaintext
	\begin{itemize}
		\item RC4 is used today
		\item can be very fast
		\item tricky to use correctly (same key for two different messages\dots)
	\end{itemize}
	\textbf{block cipher} operate on message one block at a time (64 or 128 bits)
	\begin{itemize}
		\item AES is modern implementation
		\item \textbf{mode of operation} what to do with multiple blocks
		\begin{itemize}
			\item ECB: encrypt each next block separately, you'll be able to see pattern
			\item CBC, CTR, GCM: use initial value as salt, don't expose pattern
		\end{itemize}
	\end{itemize}

	\subsection{Public-key Encryption}
	\subsubsection{Overview}
	\textbf{asymmetric cryptography} different keys for encryption, decryption
	\begin{itemize}
		\item publicize your public key
		\item other people send you messages encrypted with your public key
		\item use private key to decrypt their messages
	\end{itemize}
	Issues:
	\begin{itemize}
		\item shortcuts to crack (unlike secret-key) e.g. $2^{33}$ work to crack 128-bit RSA
		\item takes a long time to encrypt
	\end{itemize}

	\subsubsection{Hybrid cryptography}
	\textbf{hybrid cryptography} combine speed of secret key with asymmetry of public key
	\begin{itemize}
		\item pick random 128-bit key for secret-key encryption
		\item encrypt message with secret key
		\item encrypt secret key with public key of reciever
		\item send reciever secret-keyed message and public-keyed secret key
	\end{itemize}

	\subsection{Integrity}
	\subsubsection{Overview}
	Traditionally use \textbf{checksum} to verify message hasn't changed, but Mallory can usually easily change the message to maintain the checksum, so we need a \textbf{cryptographic checksum} (hard to find different message with same checksum) \\

	The method of integrity checking is just like encyrption and depends on key/secret:
	\begin{itemize}
		\item no key: cryptographic hash
		\item secret key: MAC
		\item public key: signing
	\end{itemize}

	\subsubsection{Cryptographic Hash}
	Without requiring a key we can use a \textbf{cryptographic hash} to compute $y = h(x)$, called \textbf{message digest}
	\begin{itemize}
		\item preimage-resistance: given $y$, hard to find $x$
		\item second preimage-resistance: given $x$, hard to find $x'$ where $h(x') = h(x)$
		\item collision resistance: hard to find distinct $x_1, x_2$ where $h(x_1) = h(x_2)$
	\end{itemize}
	Hash the message and send the message digest, checking the recieved message with the hash, but it only work is there is a secure way of sending the message digest


	\subsection{Authentication}
	\subsubsection{Message Authentication Codes}
	For secret key encryption, use \textbf{MAC} which :
	\begin{itemize}
		\item large class of hash functions, \textbf{MAC}s
		\item use shared secret key to pick correct one
		\item only if you know secret key, can you generate or check computed hash (\textbf{tag})
		\item SHA-1-HMAC, CBC-MAC
	\end{itemize}
	Combine with a cipher, usually Encrypt-then-MAC


	\subsubsection{Digital Signing}
	If we want to \textit{publicly} prove who sent it, \textbf{non-repudiatiation}, then use digital signatures
	\begin{itemize}
		\item sign a message with a private \textbf{signature key}
		\item verify the message with their public \textbf{verification key}
	\end{itemize}
	Signing vs public key cryptography
	\begin{itemize}
		\item hybrid signatures also available: signing a hash of the message
		\item sign your public keys to make them trustworthy
		\item signing keys are long-lived, encryption keys are short-lived
	\end{itemize}

	\subsubsection{Certificate Authorities}
	Key management is difficult, how to securely find a verification key:
	\begin{itemize}
		\item \textbf{manual keyring} know it personally, SSH
		\item \textbf{web of trust} trust a friend, PGP
		\item \textbf{certificate authority} trust a third party, TLS
	\end{itemize}
	\textbf{Certificate Authority} a third party that keeps a directory of verification keys
	\begin{itemize}
		\item a user sends the CA their verification key and signed personal information
		\item CA ensures information is correct
		\item CA generates and \textit{signs} a \textbf{certificate} of user's personal information and verification key
	\end{itemize}
	Everyone should have a copy of a CA verification key and each CA can issue certificates for CAs in levels below them
	

	\subsection{Security Controls}
	\subsubsection{Program and OS Security}
	Secret key cryptography can be difficult to defend, so use public key if local machine only needs access to public part: decryption and signature verification
	\begin{itemize}
		\item only install app if it was signed by vendor (BB)
		\item only upgrade app if it was signed by developer (Android)
		\item only allow signed executables (iOS)
	\end{itemize}
	\subsubsection{Encryption}
	Encrypted code
	\begin{itemize}
		\item processor only runs encrypted code
		\item decryption is processor-dependent
	\end{itemize}
	Encrypted data
	\begin{itemize}
		\item disk drive encryption to defend when stolen/lost
		\item doesn't protect against other users
	\end{itemize}

	\subsection{Link-layer Security}
	\subsubsection{Overview}
	Intended to protect LAN
	\begin{itemize}
		\item WEP
		\item WPA
		\item WPA2
	\end{itemize}

	\subsubsection{WEP}
	\textbf{Wired Equivalent Protocol}, not very good and multiple issues
	\begin{itemize}
		\item only changing part of key, v, is only 24 bits long
		\item checksum used is linear and easily defeated
		\item plaintext/ciphertext pair is given away by response, and allows for easy injection
		\item plaintext/ciphertext enough to get key and decrypt messages
	\end{itemize}

	\subsubsection{WPA/WPA2}
	\textbf{Wifi Protected Access} replaced WEP as a short-term patch
	\begin{itemize}
		\item replaced CRC-32 with real MAC
		\item IV is 48 bits 
		\item key changed frequently
	\end{itemize}
	\textbf{WPA2} 802.11i standard of WPA
	\begin{itemize}
		\item replace RC4 and MAC with CCM authenticated encryption mode (with AES)
		\item strong except in PSK (pre-shared key) mode
	\end{itemize}

	\subsection{Network-layer Security}
	\subsubsection{VPN}
	\textbf{Virtual Private Network} security across networks (end-to-end)
	\begin{itemize}
		\item send through local VPN gateway
		\item gateway encrypts and sends to remote gateway (e.g. tunnelling)
		\item remote gateway decrypts and sends along
	\end{itemize}
	\textbf{Tunnelling} sending the message of one protocol in payload of another, out of sequence
	\begin{itemize}
		\item IP-over-TCP, because usually it is TCP being sent over IP
		\item PPP-over-DNS, link layer over application layer
	\end{itemize}
	\subsubsection{VPN Style}
	\textbf{IPsec} standard VPN setup
	\begin{itemize}
		\item \textbf{transport} mode
			\begin{itemize}
				\item connecting a single laptop to a home network
				\item only content of original IP packet is encrypted
			\end{itemize}
		\item \textbf{tunnel} mode
			\begin{itemize}
				\item connecting two networks
				\item contents \textit{and header} of original IP packet encrypted and authenticated
				\item result placed inside new IP packet going to remote gateway
			\end{itemize}
	\end{itemize}
	\begin{description}
		\item[Microsoft PPTP] older protocol with design flaw like WEP
		\item[Tunnel PPP] IP-over-PPP-over-ssh-over-TCP-over-IP
		\item[OpenSSH] IP-over-SSH tunnelling directly
	\end{description}

	\subsection{Transport-layer}
	\subsubsection{Security}
	\textbf{TLS} standardized SSL for protecting HTTP connections
	\begin{itemize}
		\item client tells server its ciphersuites
		\item server responds with certificate
			\begin{itemize}
				\item host name
				\item verification key
				\item admin info
				\item signature from CA
			\end{itemize}
		\item server chooses ciphersuite
		\item client validates certificate
		\item client and server run agreement protocol
			\begin{itemize}
				\item establish key for symmetric encryption
				\item choose MAC algorithm from ciphersuite
			\end{itemize}
		\item now they communicate using symmetric encryption and MAC
	\end{itemize}
	TLS provides
	\begin{itemize}
		\item server auth
		\item message integrity
		\item message confidentiality
		\item client auth (optional)
	\end{itemize}

	\subsubsection{Privacy}
	\textbf{Tor} the onion router, allows making TCP connection without revealing IP
	\begin{itemize}
		\item connect to three onion routers sequentially, creating keys $k1, k2, k3$
		\item send a message M encrypted as $E_{k1}(E_{k2}(E_{k3}(M)))$, which gets decrypted along the way
		\item each node only knows the previous and next nodes, not sender or reciever
			\begin{itemize}
				\item the website only communicates with node 3
				\item node 3 communicates with node 2 and the website
				\item node 2 communicates with node 1 and node3
				\item node 1 communicates with you and node 2
			\end{itemize}
		\item replies are encrypted sequentially so that you recieve $E_{k1}(E_{k2}(E_{k3}(M)))$ 
	\end{itemize}
	Tor provides anonymity that is 
	\begin{itemize}
		\item unlinkable in the long term (connecting tomorrow is likely using different nodes)
		\item linkable in the short term (refresh will use the same nodes)
	\end{itemize}

	\subsubsection{Nymity}
	Continuum of \textbf{nymiyty}
	\begin{itemize}
		\item verinymity: ID, SIN card \dots
		\item persistent pseudonymity: username on a website
		\item linkable anonymity: prepaid phone card
		\item unlinkable anonymity: cash transaction, Tor
	\end{itemize}
	Easier to get to a higher level from lower, so always start as low as possible

	\subsection{Application-layer Security and Privacy}
	\subsubsection{Remote Login}
	\textbf{SSH} secure shell
	\begin{itemize}
		\item client connects
		\item server sends verification key
		\item client and server run agreement protocol to establish session keys
		\item client authenticates to server
		\item server accepts auth, login proceeds 
	\end{itemize}
	Two ways to authenticate
	\begin{itemize}
		\item send password over encrypted channel (server knows hash of password)
		\item sign random challenge with private signature key (server needs to know your public signature key)
	\end{itemize}

	\subsubsection{Email}
	\textbf{PGP} pretty good privacy, public-key email encryption
	\begin{itemize}
		\item hybrid encyrption of email messages 
		\item digital signatures on email messages
	\end{itemize}
	Obtaining others' public keys and signatures keys is difficult
	\begin{itemize}
		\item find \textbf{fingerprint}, cryptographic hash of the key
		\item double check fingerprints with the user or someone that knows them
		\item having a web of users verifying each other is called \textbf{web of trust}
	\end{itemize}

	\subsubsection{Instant Messaging}
	\textbf{Perfect forward secrecy} future key compromises should not reveal past communication
	\begin{itemize}
		\item use a session key created using Diffie-Hellman
		\item discard the session key after use
		\item use long-term keys to authenticate Diffie-Hellman
	\end{itemize}
	\textbf{Deniable authentication} authenticate the other person, but can't convince a third party who sent the message
	\begin{itemize}
		\item shared-key authentication to compute the MAC
		\item use MAC, so auth is deniable
	\end{itemize}
	Implementations:
	\begin{itemize}
		\item \textbf{Off-The-Record Messaging} IM providing confidentiality, deniability
		\item \textbf{Signal Protocol} extends deniability using \textbf{DAKE} (triple Diffie-Hellman key exchange)
	\end{itemize}



\end{document}
