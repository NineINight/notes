\documentclass[]{article}
\usepackage{etex}
\usepackage[margin = 1.5in]{geometry}
\setlength{\parindent}{0in}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{color}
\usepackage{mathtools}
\usepackage{pgfplots}
\usepackage[lined]{algorithm2e}
\usepackage{qtree}
\usepackage{xytree}
\usepackage{float}
\usepackage[T1]{fontenc}
\usepackage{ae,aecompl}
\usepackage[pdftex,
  pdfauthor={Michael Noukhovitch},
  pdftitle={SE 350: Operating Systems},
  pdfsubject={Lecture notes from SE 350 at the University of Waterloo},
  pdfproducer={LaTeX},
  pdfcreator={pdflatex}]{hyperref}

\usepackage{cleveref}
\usepackage{enumitem}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4
}

\theoremstyle{definition}
\newtheorem*{defn}{Definition}
\newtheorem{ex}{Example}[section]
\newtheorem*{theorem}{Theorem}

\setlength{\marginparwidth}{1.5in}
\setlength{\algomargin}{0.75em}

\DeclarePairedDelimiter{\set}{\lbrace}{\rbrace}

\definecolor{darkish-blue}{RGB}{25,103,185}

\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=darkish-blue,
    filecolor=darkish-blue,
    linkcolor=darkish-blue,
    urlcolor=darkish-blue
}
\newcommand{\lecture}[1]{\marginpar{{\footnotesize $\leftarrow$ \underline{#1}}}}

\makeatletter
\def\blfootnote{\gdef\@thefnmark{}\@footnotetext}
\makeatother

\begin{document}
	\let\ref\Cref

	\title{\bf{SE 350: Operating Systems}}
	\date{Winter 2015, University of Waterloo \\ \center Notes written from Thomas Reidemeister's lectures.}
	\author{Michael Noukhovitch}

	\maketitle
	\newpage
	\tableofcontents
	\newpage

	\section{Introduction}
		\subsection{Definitions}
			\textbf{Operating Systems}: a standardized abstraction from hardware that:
			\begin{itemize}
				\item manages resources
				\item provides set of services
				\item consumes resources
			\end{itemize}
			\textbf{Instruction execution}:
			\begin{enumerate}
				\item fetches instruction into IR
				\item executes instruction
			\end{enumerate}
			In reality, it is a bit more complicated: there is a pipeline, out of order execution... 
		\subsection{Interrupts}
			\subsubsection{Type of interrupts}
				\begin{itemize}
					\item \textbf{program} result of instruction execution e.g. arithmetic overflow
					\item \textbf{timer} timer within process, allows OS to perform regular functions
					\item \textbf{I/O} generated by I/O controller
					\item \textbf{hardware failure} power failure or memory parity failure
				\end{itemize}
			\subsubsection{How interrupts work}
				Hardware:				
				\begin{enumerate}
					\item interrupt issued
					\item processor finishes current instruction
					\item acknowledge interrupt
					\item push PSW and PC onto control stack
					\item load new PC
				\end{enumerate}
				Software:
				\begin{enumerate}[resume]									
					\item save remainder of process state
					\item interrupt
					\item restore process state information
					\item restore PSW and PC
				\end{enumerate}
			\subsection{Multiple interrupts}
				Two ways of handling an interrupt during an interrupt:
				\subsubsection{Sequential}
					Ignore any interrupts when you are in an interrupt and when done, check for interrupts that occurred.
				\subsubsection{Nested}
					If the second interrupt is of higher priority, recurse into it. Otherwise, wait until interrupt is finished.
		\subsection{Peripheral interrupts}
			Peripherals such as hard drives take a while to complete their action. As opposed to waiting and wasting that time, we use an interrupt to execute other instructions while our I/O process runs.
			\subsubsection{Programmed I/O}
				No interrupts occur, just wait until the I/O is complete
			\subsubsection{Interrupt-driven I/O}
				Processor interrupted when I/O is ready and all writes/reads are passed through CPU into memory. This is faster, since there is no waiting. 
			\subsubsection{Direct memory access}
				Transfers a block of data directly into memory and interrupt is sent when process is complete. This is more efficient because data does not need to go through CPU. Not always available (e.g. external peripheral) 
		\subsection{Memory hierarchy}
			Major constraints in memory:
			\begin{itemize}
				\item size
				\item speed
				\item cost
			\end{itemize}
			
			\subsubsection{Hierarchy}
			Top: Inboard memory \\
			Middle: Outboard storage \\
			Bottom: Offline storage \\

			\subsubsection{Cache}
				\textbf{Cache}: small, fast memory, invisible to the OS, that speeds up accesses exploiting the principle of locality
	
	\section{Operating Systems Overview}
		\subsection{Definition}
			\textbf{Operating System} a program that controls the execution of applications and is a standard interface between hardware and software
			\begin{itemize}
				\item \textbf{convenience}: need no knowledge of hardware
				\item \textbf{efficiency}: move optimization from devs to tools
				\item \textbf{ability to evolve}: can replace internals
			\end{itemize}
			\textbf{Kernel}: portion of the OS in main memory; a nucleus that contains frequently used functions
			\textbf{OS services}
			\begin{itemize}
				\item program development and execution
				\item access \& control of access to I/O
				\item system access control
				\item error detection and response
				\item accounting
			\end{itemize}
		\subsection{OS Innovations}
			\subsubsection{Hardware Features}
				\begin{itemize}
					\item \textbf{Memory protection}: do not allow memory containing monitor to be altered
					\item \textbf{Timer}: prevents a job from monopolizing system
					\item \textbf{Privileged instruction}: certain instructions can only be executed by the monitor (e.g. I/O)
					\item \textbf{Interrupts}
				\end{itemize}
			\subsubsection{Modes of operation}
				To protect users from each other (and the kernel from user), we have two modes:
				\begin{itemize}
					\item \textbf{User mode}: not privileged
					\item \textbf{Kernel mode}: privileged and access to protected memory
				\end{itemize}
			\subsubsection{Multiprogramming}
				When one job needs to wait for I/O, the processor can switch to another job. The timer is also used to switch processes and stop monopolization.
				\begin{itemize}
					\item maximize processor use
					\item use job control language 
				\end{itemize}
			\subsubsection{Time Sharing}
				Processor time is shared by multiple users
				\begin{itemize}
					\item minimize response time
				\end{itemize}
		\subsection{Major Achievements}
			\subsubsection{Processes}
				\textbf{Process}: a program in execution
				\begin{itemize}
					\item a program
					\item associated data
					\item execution content (needed by OS)
				\end{itemize}
			\subsubsection{Memory Management}
				\begin{itemize}
					\item process isolation
					\item automatic allocation
						\begin{itemize}
							\item virtual memory: allows programmer to address memory without regard to physical addressing
							\item paging: allows processes to be comprised of fixed-size blocks (pages)
						\end{itemize}
					\item swap program code
					\item shared memory
					\item long term storage
				\end{itemize}
			\subsubsection{Information Security}
				\begin{itemize}
					\item availability:	protecting system against interruption (downtime)
					\item confidentiality: 	authorizing data (chmod)
					\item data integrity:	protect from modification
					\item authenticity:	verifying identity of users 
				\end{itemize}
			\subsubsection{Scheduling and Resource Management}
				\begin{itemize}
					\item fairness:	give equal access to resources
					\item differential responsiveness:	discriminate by class of jobs
					\item efficiency:	maximize throughput
				\end{itemize}
			\subsubsection{System Structure}
				The system as a hierarchical structure with each level relying on lower levels for its functions.
				\begin{enumerate}
					\item circuits:	registers, gates, buffers
					\item instructions: add, subtract, load, store
					\item procedures: 	call stack, subroutine
					\item interrupts
					\item processes:	suspend, wait, resume
					\item local store:	blocks of data, allocate
					\item virtual memory:	segments, pages
					\item communications:	pipes
					\item file system:	files 
					\item external devices
					\item directories
					\item user process
					\item shell	 
				\end{enumerate}
		\subsection{Modern Operating System}
			Developments leading to modern operating systems:
			\begin{itemize}			
				\item \textbf{Microkernel architecture}:	only essentials to kernel, everything else in user space (e.g. QNX)
				\item \textbf{Multithreading}:	process divided into concurrent threads
				\item \textbf{Symmetric multiprocessing}:	multiple processors share main memory and I/O
				\item \textbf{Distributed OS}:	illusion of a single main and secondary memory
				\item \textbf{Asymmetric multiprocessing}:	one big processor controls many small ones			
				\item \textbf{Object oriented design}:	customize OS without disrupting system
			\end{itemize}
\end{document}
